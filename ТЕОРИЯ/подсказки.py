
import time

"""
Наследование — способ создания класса. Функциональность нового класса наследуются от уже 
существующего класса. Новый класс называется производным (дочерним). Существующий — базовым (родительским).

Инкапсуляция
Ограничение доступа к методам и переменным.
 Приватные атрибуты выделяются нижним подчеркиванием: одинарным _ или двойным __. 
 
Полиморфизм — особенность ООП, позволяющая использовать одну функцию для разных форм (типов данных).
"""
"""Паттерны - фабричный метод, декоратор, Абстрактная фабрика"""

"""Типы данных"""
"""НЕ ИЗМЕНЯЕМЫЙ"""
string_s1 = 'строка не изменяемый тип данных, поэтому каждый раз пересохраняется'
int_i1 = 123124 # целое число без запятой , НЕ ИЗМЕНЯЕМЫЙ
float_f1 = 3.14 # вещественное число с плавающей точкой, НЕ ИЗМЕНЯЕМЫЙ
float_f2 = 2e4 # вещественное число с плавающей точкой, НЕ ИЗМЕНЯЕМЫЙ
complex_c1 = 3 + 4j  # комплексное число, НЕ ИЗМЕНЯЕМЫЙ
tupple_t1 = ('a', 1) #кортеж, неизменяемая УПОРЯДОЧЕННАЯ последовательность объектов, НЕ ИЗМЕНЯЕМЫЙ
bool_b1 = True #Булево значение Тру-фолсе , НЕ ИЗМЕНЯЕМЫЙ

"""Изменяемый"""
list_l1 = [1, 2]  # список, УПОРЯДОЧЕННАЯ последовательность объектов
dict_d1 = {'ключ': 'значение'}  # словарь, набор НЕупорядоченных пар ключ-значение, он же ХЭШ-таблица,  ключём может быть НЕ изменяемый тип данных
set_s1 = {'a', 'b'} # множество, НЕупорядоченный набор уникальный объектов




# Итератор это объект  который поддерживает функцию next()
iterator_i1 = iter([1, 'a',  None])
print(next(iterator_i1))
print(next(iterator_i1))
print(next(iterator_i1))

#Генератор списка
a = [i**2 for i in range(1, 5)]
# или
def create_generator():
    for i in os.wolk('c:\\'):
        yield i[0]
x = create_generator() # теперь генератор

#вырожение генератора списка
generator_g1 = (i**2 for i in range(1, 5)) # генератор - это итератор, элементы которого можно итерировать только 1 раз
print(a)



#Коды ответов от http
"""
100-199 - информационный
200-299 - Успешный
300-399 - перенаправление
400-499 Клиентские ошибки , возможно клиент не то отправил
500-599 проблемы с сервером
"""

#структура http
"""
HTTP Request
======================================================================================
Строка запроса - GET, POST     < GET  http://www.exp.ru  HTTP/1.1 >
Заголовок  - например  < HOST: http://www.exp.ru , User-Agent: Mazilla/5.0 >
body - тело, данные
======================================================================================


HTTP responce 
======================================================================================
            < HTTP/1.1  200   OK                 >
                версия, код, текстовое описание
======================================================================================


GET - обычно получить информацию, может передавать параметры прямо в строке адреса, не должны делать изменения на сервере
POST - создание чего-то нового на сервере
PUT - изменение на сервере
DELETE - удаление

"""

# Реалиционные БД
'''
Left       key1 | null

right    null | key1

inner - пересечения слева и справа 
outer - объединяется всё, если нет пересечений то ставится Null

SQL HAVING после Group by для операций Min max... 
'''
"INSERT INTO user (col1, col2, col3) VALUES ('val1', 'val2','val3')"
"SELECT * from user  WHERE col1 == 'val1'"
"DELETE * from user  WHERE col1 == 'val1'"
"TRUNCATE * from user "


""" Транзакция - группа последовательных операций с БД, которая представляет собой логическую единицу работы с данными
BEGIN ... COMMIT;  / BEGIN ... ROLLBACK;"""


"""Многопроцессорность (multiprocessing) - это подход, при котором задачи выполняются в отдельных процессах."""
"""Асинхронность (asyncio ) - это подход, при котором задачи выполняются независимо друг от друга без блокировки основного потока выполнения."""
""" Многопоточность (threading) - это подход, при котором задачи выполняются в отдельных потоках внутри одного процесса"""
# Пример потоков++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
from threading import Thread

def func1():
    print('первая функция')
    time.sleep(5)
    print('первая всё')

def func2():
    print('вторая функция')
    time.sleep(5)
    print('вторая всё')

th1 = Thread(target=func1())
th1.start()
th2 = Thread(target=func2())
th2.start()

'''Loop -  цикл событий'''


# Магические методы
"""
Магические методы переопределяет поведение объектов для стандартных функций
__STR__ __init__ __del__ __anatations__
"""

# UnitTest
'''
import unittest
import my_foo
class TestCalc(unittest.TestCase):
    def testCalc(self):
        self.assertEquals(my_calc.addition(2,2) 4)
if __name__ == '__main__':
    unittest.main
'''
# Конетекстный менеджер - спец конструкция управления ресурсом

# *args - кортеж
# *kwargs - словарь

"""
если файл открыть open то какой тип данных будет?
уменьшить вводную часть
больше про стек и библиотеки
размеры - например приложение обрабатывало 1000 файлов в секунду
+ структура команды , 3 разраба, тимлид, ...
была jira . confluence
был ли ci/cd
потренить sql например сделать выборку из БД, по атрибуду и сложить что получилось
"""

# Принципы SOLID

#
# S – Single Responsibility (Принцип единственной ответственности) Каждый класс должен отвечать только за одну операцию
# O — Open-Closed (Принцип открытости-закрытости) Классы должны  быть  открыты для расширения, но закрыты для модификации.

#
# new_list = []
#
#
# def flatten(seq):
#     for val in seq:
#         print(val)
#         if type(val) is list:
#             print('нашёл лист')
#             flatten(val)
#         else:
#             new_list.append(val)
#     return new_list
#
#     # raise NotImplemented
#
#
# a = [1, 2, 3, [4, [5, 6, 7]], [8], 9, [10, ], [], 11, [12, 13, 14], 15]
#
# result = flatten(a)
#
# print(f'->{result}')
#
# assert result == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
# использовать как генератор
# без рекурсии*
#
def flatten(seq):
    for val in seq:
        if isinstance(val, list):
            yield from flatten(val)
        else:
            yield val

a = [1, 2, 3, [4, [5, 6, 7]], [8], 9, [10, ], [], 11, [12, 13, 14], 15]
result = list(flatten(a))
print(result)